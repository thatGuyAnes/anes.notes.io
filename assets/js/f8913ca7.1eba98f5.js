"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[8694],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=s(n),d=a,f=m["".concat(u,".").concat(d)]||m[d]||p[d]||i;return n?r.createElement(f,l(l({ref:t},c),{},{components:n})):r.createElement(f,l({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4535:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return c},default:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),l=["components"],o={title:"Functional patterns with ramdajs"},u=void 0,s={unversionedId:"notes/functional_with_reamda",id:"notes/functional_with_reamda",isDocsHomePage:!1,title:"Functional patterns with ramdajs",description:"Objectives:",source:"@site/docs/notes/functional_with_reamda.md",sourceDirName:"notes",slug:"/notes/functional_with_reamda",permalink:"/notes/docs/notes/functional_with_reamda",editUrl:"https://github.com/thatGuyAnes/notes/docs/notes/functional_with_reamda.md",tags:[],version:"current",frontMatter:{title:"Functional patterns with ramdajs"},sidebar:"mySidebar",previous:{title:"Docusaurus",permalink:"/notes/docs/notes/docusaurus"},next:{title:"GraphQl",permalink:"/notes/docs/notes/graphql"}},c=[{value:"Objectives:",id:"objectives",children:[],level:2},{value:"Pure Functions",id:"pure-functions",children:[{value:"Rules",id:"rules",children:[],level:3},{value:"Side-Effects",id:"side-effects",children:[],level:3}],level:2},{value:"HOFs",id:"hofs",children:[{value:"First Class Citizens",id:"first-class-citizens",children:[],level:3}],level:2},{value:"Composition",id:"composition",children:[{value:"Curried Functions",id:"curried-functions",children:[],level:3},{value:"Point-Free",id:"point-free",children:[],level:3},{value:"Data Last",id:"data-last",children:[],level:3}],level:2},{value:"More on Currying",id:"more-on-currying",children:[{value:"Proper Curry",id:"proper-curry",children:[],level:3}],level:2}],p={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"objectives"},"Objectives:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To have a better understanding of the purely fp patterns in a friendly\nenvironment (without the need to learn haskell)."),(0,i.kt)("li",{parentName:"ul"},"To solidify some already known principles like currying, composition, higher\norder functions etc."),(0,i.kt)("li",{parentName:"ul"},"Thinking in abstraction vs implementations details.")),(0,i.kt)("p",null,"From the get go these terminologies and concepts should bring a better\nunderstanding of the functional programming patterns:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pure functions"),(0,i.kt)("li",{parentName:"ul"},"Immutability"),(0,i.kt)("li",{parentName:"ul"},"Side-Effects"),(0,i.kt)("li",{parentName:"ul"},"Shared State"),(0,i.kt)("li",{parentName:"ul"},"First-Class Citizen (HOFs)")),(0,i.kt)("h2",{id:"pure-functions"},"Pure Functions"),(0,i.kt)("h3",{id:"rules"},"Rules"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Never mutate the input."),(0,i.kt)("li",{parentName:"ul"},"We can safely mutate a CLONE of an input, NEVER the input itself.")),(0,i.kt)("p",null,"The easiest way to clone arrays and objects is tot use spread syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"const original = { name: 'Jhon' }\nconst clone    = { ...original }\n")),(0,i.kt)("h3",{id:"side-effects"},"Side-Effects"),(0,i.kt)("p",null,"Keywords:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Shared state"),(0,i.kt)("li",{parentName:"ul"},"Time dependency")),(0,i.kt)("p",null,'An assignment statement(x=y) introduces a "time dependency" (state\nmanagement issue) like in the following example:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let count = 5;\n\nconst add = (number) => (count += number);\n\nadd(4); // count is 9\nadd(4); // count is 13 !!!!!\n")),(0,i.kt)("p",null,"Anything the function performs that is not related to calculating its output,\nis a side-effect"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"mutating the input"),(0,i.kt)("li",{parentName:"ul"},"HTTP calls (fetch/AJAX)"),(0,i.kt)("li",{parentName:"ul"},"console.log (printing to the screen)"),(0,i.kt)("li",{parentName:"ul"},"querying the DOM"),(0,i.kt)("li",{parentName:"ul"},"writing to disk")),(0,i.kt)("p",null,"Shared state = timing dependencies."),(0,i.kt)("h2",{id:"hofs"},"HOFs"),(0,i.kt)("h3",{id:"first-class-citizens"},"First Class Citizens"),(0,i.kt)("p",null,"Objects, Arrays, Numbers, Booleans and Strings are considered as first-class. Why?\nbecause they can be stored in variables, passed around as arguments."),(0,i.kt)("p",null,"And Functions are first-class by that definition:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We can pass them as args to other functions."),(0,i.kt)("li",{parentName:"ul"},"Set them as objects' properties."),(0,i.kt)("li",{parentName:"ul"},"Set them as variables."),(0,i.kt)("li",{parentName:"ul"},"Store them in arrays.")),(0,i.kt)("p",null,'A Higher Order Function is a function that takes or/and returns another function.\n"higher" meaning it deals with functions(which are first-citizens) in addition\nto strings, arrays, objects etc'),(0,i.kt)("h2",{id:"composition"},"Composition"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://memegenerator.net/img/instances/82112524/yo-dawg-i-heard-you-like-functions-so-i-put-functions-inside-your-functions-so-you-can-evaluate-a-fu.jpg",alt:"FunctionInsideFunction"})),(0,i.kt)("p",null,"To compose means to create by combining things."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { map } from 'ramda'\n\nconst double  = (numb) => numb * 2\nconst numbers = [1, 2, 3, 4, 5]\n\n// composing\nconst doubleNumbers = map(double)\nconst result3       = doubleNumbers(numbers)\n")),(0,i.kt)("h3",{id:"curried-functions"},"Curried Functions"),(0,i.kt)("p",null,"Everything in Ramda is curried!"),(0,i.kt)("p",null,"A curried function can take some parameters now, other later by returning a\nfunction that waits for its arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const doubleNumbers = map(double)\ndoubleNumbers(numbers)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"doubleNumbers"),' is curried, it will wait for the other arguments to run, it\n"preloads" the Ramda\'s map function.'),(0,i.kt)("h3",{id:"point-free"},"Point-Free"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"doubleNumbers = map(double)")," we didn't pass a number parameter to the map function.\nneither when we called it with ",(0,i.kt)("inlineCode",{parentName:"p"},"numbers"),". These functions don't say the data\nthey're operating on (",(0,i.kt)("inlineCode",{parentName:"p"},"number"),")."),(0,i.kt)("p",null,"Where functions don't show their arguments!!!"),(0,i.kt)("p",null,"This ",(0,i.kt)("em",{parentName:"p"},"style")," is called ",(0,i.kt)("strong",{parentName:"p"},"Point-Free")," enabled by HOFs and currying."),(0,i.kt)("h3",{id:"data-last"},"Data Last"),(0,i.kt)("p",null,"In Ramda, function are curried and they take the data last(arguments) making it\neasier to point-free."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// build in map function\nnumbers.map(double)\n\n// data last using Ramda\nmap(double, numbers)\n")),(0,i.kt)("h2",{id:"more-on-currying"},"More on Currying"),(0,i.kt)("p",null,"The biggest benefit of currying, is that is makes the code DRYer by making the\nfunctions reusable."),(0,i.kt)("p",null,"Currying lets you partially apply a function and create more specialized versions."),(0,i.kt)("p",null,"Currying a function can save us from bugs in our code, like the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const sum = (a, b) => a + b\nconst result = sum(5) // returns NaN, as b in undefined\n")),(0,i.kt)("p",null,"This is not bueno!!! let's fix it using ",(0,i.kt)("strong",{parentName:"p"},"currying"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { curry } from 'ramda' // ramda's curry function\n\nconst sum = (a,b) => a + b\nconst curriedSum = curry(sum)\nconst result = curriedSum(5) // returns a function\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"result")," will return a function, because it's curried, it'll always return a\nfunction that waits for its last argument (in this case the second number ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),")!"),(0,i.kt)("h3",{id:"proper-curry"},"Proper Curry"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://www.freecodecamp.org/news/content/images/2019/07/dog-properly-currying-a-function-1.jpeg",alt:"properCurry"})),(0,i.kt)("p",null,'The bible of FP says that "',(0,i.kt)("em",{parentName:"p"},"a curried function must always return a new\nfunction for each parameter"),'". For example:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const properlyCurriedMultiply3 = (a) => (b) => (c) => a * b * c\n\nproperlyCurriedMultiply3(2)(5)(10) // --\x3e 100\n")),(0,i.kt)("p",null,"But in Ramda, we can use either styles, like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { curry } from 'ramda'\n\nconst multiply3 = (a,b,c) => a * b * c\nconst curriedMultiply3 = curry(multiply3)\n\n// Provide all arguments at once!!\ncurriedMultiply3(5, 3, 2) // --\x3e 30\n\n// Break it up\ncurriedMultiply3(5)(3)(2) // --\x3e 30\n\n// This is also valid\ncurriedMultiply3(5)()()(3)()(2)\n")))}m.isMDXComponent=!0}}]);